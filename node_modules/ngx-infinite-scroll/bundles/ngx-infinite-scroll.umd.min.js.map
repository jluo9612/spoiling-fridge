{"version":3,"file":"ngx-infinite-scroll.umd.min.js","sources":["../../src/services/ngx-ins-utils.ts","../../src/services/event-trigger.ts","../../src/services/position-resolver.ts","../../src/services/scroll-resolver.ts","../../src/services/scroll-register.ts","../../src/services/axis-resolver.ts","../../src/modules/infinite-scroll.directive.ts","../../src/modules/ngx-infinite-scroll.module.ts"],"sourcesContent":["import * as console from 'console';\nimport { ElementRef, SimpleChange } from '@angular/core';\n\nexport function resolveContainerElement(\n  selector: string | any,\n  scrollWindow,\n  defaultElement,\n  fromRoot: boolean\n): any {\n  const hasWindow = window && !!window.document && window.document.documentElement;\n  let container = hasWindow && scrollWindow ? window : defaultElement;\n  if (selector) {\n    const containerIsString =\n      selector && hasWindow && typeof selector === 'string';\n    container = containerIsString\n      ? findElement(selector, defaultElement.nativeElement, fromRoot)\n      : selector;\n    if (!container) {\n      throw new Error('ngx-infinite-scroll {resolveContainerElement()}: selector for');\n    }\n  }\n  return container;\n}\n\nexport function findElement(\n  selector: string | any,\n  customRoot: ElementRef | any,\n  fromRoot: boolean\n) {\n  const rootEl = fromRoot ? window.document : customRoot;\n  return rootEl.querySelector(selector);\n}\n\nexport function inputPropChanged(prop: SimpleChange): boolean {\n  return prop && !prop.firstChange;\n}\n\nexport function hasWindowDefined(): boolean {\n  return typeof window !== 'undefined';\n}\n","import { InfiniteScrollEvent, IPositionStats } from '../models';\n\nexport interface IScrollerProps {\n  container: IPositionStats;\n  down: number;\n  up: number;\n  alwaysCallback: boolean;\n  disabled: boolean;\n}\n\nexport interface ITriggerEvents {\n  down: (event: any) => any;\n  up: (event: any) => any;\n}\n\nexport interface IDistanceRange {\n  down: number;\n  up: number;\n}\n\nexport interface IScrollConfig {\n  alwaysCallback: boolean;\n  shouldFireScrollEvent: boolean;\n}\n\nexport function shouldTriggerEvents(\n  alwaysCallback: boolean,\n  shouldFireScrollEvent: boolean,\n  isTriggeredCurrentTotal: boolean) {\n  return (alwaysCallback || shouldFireScrollEvent) && !isTriggeredCurrentTotal;\n}\n","import { ElementRef } from '@angular/core';\n\nimport { ContainerRef, IPositionElements, IPositionStats, IResolver } from '../models';\nimport { AxisResolver } from './axis-resolver';\n\nexport function createResolver({\n  windowElement,\n  axis\n}: IPositionElements): IResolver {\n  return createResolverWithContainer(\n    { axis, isWindow: isElementWindow(windowElement) },\n    windowElement\n  );\n}\n\nexport function createResolverWithContainer(\n  resolver,\n  windowElement: ContainerRef\n) {\n  const container =\n    resolver.isWindow || (windowElement && !windowElement.nativeElement)\n      ? windowElement\n      : windowElement.nativeElement;\n  return { ...resolver, container };\n}\n\nexport function isElementWindow(windowElement: ContainerRef): boolean {\n  const isWindow = ['Window', 'global'].some((obj: string) =>\n    Object.prototype.toString.call(windowElement).includes(obj)\n  );\n  return isWindow;\n}\n\nexport function getDocumentElement(isContainerWindow: boolean, windowElement) {\n  return isContainerWindow ? windowElement.document.documentElement : null;\n}\n\nexport function calculatePoints(element: ElementRef, resolver: IResolver) {\n  const height = extractHeightForElement(resolver);\n  return resolver.isWindow\n    ? calculatePointsForWindow(height, element, resolver)\n    : calculatePointsForElement(height, element, resolver);\n}\n\nexport function calculatePointsForWindow(\n  height: number,\n  element: ElementRef,\n  resolver: IResolver\n): IPositionStats {\n  const { axis, container, isWindow } = resolver;\n  const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);\n  // scrolled until now / current y point\n  const scrolled =\n    height +\n    getElementPageYOffset(\n      getDocumentElement(isWindow, container),\n      axis,\n      isWindow\n    );\n  // total height / most bottom y point\n  const nativeElementHeight = getElementHeight(\n    element.nativeElement,\n    isWindow,\n    offsetHeightKey,\n    clientHeightKey\n  );\n  const totalToScroll =\n    getElementOffsetTop(element.nativeElement, axis, isWindow) +\n    nativeElementHeight;\n  return { height, scrolled, totalToScroll };\n}\n\nexport function calculatePointsForElement(\n  height: number,\n  element: ElementRef,\n  resolver: IResolver\n): IPositionStats {\n  const { axis, container } = resolver;\n  // perhaps use container.offsetTop instead of 'scrollTop'\n  const scrolled = container[axis.scrollTopKey()];\n  const totalToScroll = container[axis.scrollHeightKey()];\n  return { height, scrolled, totalToScroll };\n}\n\nexport function extractHeightPropKeys(axis: AxisResolver) {\n  return {\n    offsetHeightKey: axis.offsetHeightKey(),\n    clientHeightKey: axis.clientHeightKey()\n  };\n}\n\nexport function extractHeightForElement({\n  container,\n  isWindow,\n  axis\n}: IResolver) {\n  const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);\n  return getElementHeight(\n    container,\n    isWindow,\n    offsetHeightKey,\n    clientHeightKey\n  );\n}\nexport function getElementHeight(\n  elem: any,\n  isWindow: boolean,\n  offsetHeightKey: string,\n  clientHeightKey: string\n) {\n  if (isNaN(elem[offsetHeightKey])) {\n    return getDocumentElement(isWindow, elem)[clientHeightKey];\n  } else {\n    return elem[offsetHeightKey];\n  }\n}\n\nexport function getElementOffsetTop(\n  elem: ContainerRef,\n  axis: AxisResolver,\n  isWindow: boolean\n) {\n  const topKey = axis.topKey();\n  // elem = elem.nativeElement;\n  if (!elem.getBoundingClientRect) {\n    // || elem.css('none')) {\n    return;\n  }\n  return (\n    elem.getBoundingClientRect()[topKey] +\n    getElementPageYOffset(elem, axis, isWindow)\n  );\n}\n\nexport function getElementPageYOffset(\n  elem: ContainerRef,\n  axis: AxisResolver,\n  isWindow: boolean\n) {\n  const pageYOffset = axis.pageYOffsetKey();\n  const scrollTop = axis.scrollTopKey();\n  const offsetTop = axis.offsetTopKey();\n\n  if (isNaN(window[pageYOffset])) {\n    return getDocumentElement(isWindow, elem)[scrollTop];\n  } else if (elem.ownerDocument) {\n    return elem.ownerDocument.defaultView[pageYOffset];\n  } else {\n    return elem[offsetTop];\n  }\n}\n","import { IPositionStats, IScrollState, IScrollerDistance } from '../models';\n\nexport function shouldFireScrollEvent(\n  container: IPositionStats,\n  distance: IScrollerDistance,\n  scrollingDown: boolean\n) {\n  let remaining: number;\n  let containerBreakpoint: number;\n  const scrolledUntilNow = container.height + container.scrolled;\n  if (scrollingDown) {\n    remaining = (container.totalToScroll - scrolledUntilNow) / container.totalToScroll;\n    containerBreakpoint = distance.down / 10;\n  } else {\n    remaining = scrolledUntilNow / container.totalToScroll;\n    containerBreakpoint = distance.up / 10;\n  }\n\n  const shouldFireEvent: boolean = remaining <= containerBreakpoint;\n  return shouldFireEvent;\n}\n\nexport function isScrollingDownwards(\n  lastScrollPosition: number,\n  container: IPositionStats\n) {\n  return lastScrollPosition < container.scrolled;\n}\n\nexport function getScrollStats(\n  lastScrollPosition: number,\n  container: IPositionStats,\n  distance: IScrollerDistance\n) {\n  const scrollDown = isScrollingDownwards(lastScrollPosition, container);\n  return {\n    fire: shouldFireScrollEvent(container, distance, scrollDown),\n    scrollDown\n  };\n}\n\nexport function updateScrollPosition(position: number, scrollState: IScrollState) {\n  return (scrollState.lastScrollPosition = position);\n}\n\nexport function updateTotalToScroll(totalToScroll: number, scrollState: IScrollState) {\n  if (scrollState.lastTotalToScroll !== totalToScroll) {\n    scrollState.lastTotalToScroll = scrollState.totalToScroll;\n    scrollState.totalToScroll = totalToScroll;\n  }\n}\n\nexport function isSameTotalToScroll(scrollState: IScrollState) {\n  return scrollState.totalToScroll === scrollState.lastTotalToScroll;\n}\n\nexport function updateTriggeredFlag(scroll, scrollState: IScrollState, triggered: boolean, isScrollingDown: boolean) {\n  if (isScrollingDown) {\n    scrollState.triggered.down = scroll;\n  } else {\n    scrollState.triggered.up = scroll;\n  }\n}\n\nexport function isTriggeredScroll(totalToScroll, scrollState: IScrollState, isScrollingDown: boolean) {\n  return isScrollingDown\n    ? scrollState.triggered.down === totalToScroll\n    : scrollState.triggered.up === totalToScroll;\n}\n\nexport function updateScrollState(\n  scrollState: IScrollState, scrolledUntilNow: number, totalToScroll: number) {\n  updateScrollPosition(scrolledUntilNow, scrollState);\n  updateTotalToScroll(totalToScroll, scrollState);\n  // const isSameTotal = isSameTotalToScroll(scrollState);\n  // if (!isSameTotal) {\n  //   updateTriggeredFlag(scrollState, false, isScrollingDown);\n  // }\n}\n","import 'rxjs/add/observable/fromEvent';\nimport 'rxjs/add/observable/of';\nimport 'rxjs/add/operator/filter';\nimport 'rxjs/add/operator/mergeMap';\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/do';\nimport 'rxjs/add/operator/sampleTime';\n\nimport { ElementRef } from '@angular/core';\nimport { Observable } from 'rxjs/Observable';\nimport { map } from 'rxjs/operator/map';\nimport { of } from 'rxjs/observable/of';\n\nimport * as Models from '../models';\nimport { AxisResolver } from './axis-resolver';\nimport { shouldTriggerEvents, IScrollConfig } from './event-trigger';\nimport { resolveContainerElement } from './ngx-ins-utils';\nimport { calculatePoints, createResolver } from './position-resolver';\nimport * as ScrollResolver from './scroll-resolver';\n\nexport function createScroller(config: Models.IScroller) {\n  const { scrollContainer, scrollWindow, element, fromRoot } = config;\n  const resolver = createResolver({\n    axis: new AxisResolver(!config.horizontal),\n    windowElement: resolveContainerElement(scrollContainer, scrollWindow, element, fromRoot)\n  });\n  const { totalToScroll: startWithTotal } = calculatePoints(element, resolver);\n  const scrollState: Models.IScrollState = {\n    lastScrollPosition: 0,\n    lastTotalToScroll: 0,\n    totalToScroll: startWithTotal,\n    triggered: {\n      down: 0,\n      up: 0\n    }\n  };\n  const options: Models.IScrollRegisterConfig = {\n    container: resolver.container,\n    throttle: config.throttle\n  };\n  const distance = {\n    up: config.upDistance,\n    down: config.downDistance\n  };\n  return attachScrollEvent(options)\n    .mergeMap((ev: any) => of(calculatePoints(element, resolver)))\n    .map((positionStats: Models.IPositionStats) =>\n      toInfiniteScrollParams(scrollState.lastScrollPosition, positionStats, distance))\n    .do(({ stats, scrollDown }: Models.IScrollParams) =>\n      ScrollResolver.updateScrollState(\n        scrollState,\n        stats.scrolled,\n        stats.totalToScroll,\n      ))\n    .filter(({ fire, scrollDown, stats: { totalToScroll } }: Models.IScrollParams) =>\n      shouldTriggerEvents(\n        fire, config.alwaysCallback, ScrollResolver.isTriggeredScroll(totalToScroll, scrollState, scrollDown))\n    )\n    .do(({ scrollDown, stats: { totalToScroll } }: Models.IScrollParams) => {\n      ScrollResolver.updateTriggeredFlag(totalToScroll, scrollState, true, scrollDown);\n    })\n    .map(toInfiniteScrollAction);\n}\n\nexport function attachScrollEvent(options: Models.IScrollRegisterConfig): Observable<{}> {\n  return Observable\n    .fromEvent(options.container, 'scroll')\n    .sampleTime(options.throttle);\n}\n\nexport function toInfiniteScrollParams(\n  lastScrollPosition: number,\n  stats: Models.IPositionStats,\n  distance: Models.IScrollerDistance\n): Models.IScrollParams {\n  const { scrollDown, fire } = ScrollResolver.getScrollStats(\n    lastScrollPosition,\n    stats,\n    distance\n  );\n  return {\n    scrollDown,\n    fire,\n    stats\n  };\n}\n\nexport const InfiniteScrollActions = {\n  DOWN: '[NGX_ISE] DOWN',\n  UP: '[NGX_ISE] UP'\n};\n\nexport function toInfiniteScrollAction(response: Models.IScrollParams): Models.IInfiniteScrollAction {\n  const { scrollDown, stats: { scrolled: currentScrollPosition } } = response;\n  return {\n    type: scrollDown ? InfiniteScrollActions.DOWN : InfiniteScrollActions.UP,\n    payload: {\n      currentScrollPosition\n    }\n  };\n}\n","export class AxisResolver {\n  constructor(private vertical: boolean = true) {\n  }\n  clientHeightKey() { return this.vertical ? 'clientHeight' : 'clientWidth'; }\n  offsetHeightKey() { return this.vertical ? 'offsetHeight' : 'offsetWidth'; }\n  scrollHeightKey() { return this.vertical ? 'scrollHeight' : 'scrollWidth'; }\n  pageYOffsetKey() { return this.vertical ? 'pageYOffset' : 'pageXOffset'; }\n  offsetTopKey() { return this.vertical ? 'offsetTop' : 'offsetLeft'; }\n  scrollTopKey() { return this.vertical ? 'scrollTop' : 'scrollLeft'; }\n  topKey() { return this.vertical ? 'top' : 'left'; }\n}\n","import {\n  AfterViewInit,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  Output,\n  SimpleChanges\n} from '@angular/core';\nimport { Subscription } from 'rxjs/Subscription';\n\nimport { InfiniteScrollEvent, IInfiniteScrollAction } from '../models';\nimport { hasWindowDefined, inputPropChanged } from '../services/ngx-ins-utils';\nimport { createScroller, InfiniteScrollActions } from '../services/scroll-register';\n\n@Directive({\n  selector: '[infiniteScroll], [infinite-scroll], [data-infinite-scroll]'\n})\nexport class InfiniteScrollDirective\n  implements OnDestroy, OnChanges, AfterViewInit {\n  @Output() scrolled = new EventEmitter<InfiniteScrollEvent>();\n  @Output() scrolledUp = new EventEmitter<InfiniteScrollEvent>();\n\n  @Input() infiniteScrollDistance: number = 2;\n  @Input() infiniteScrollUpDistance: number = 1.5;\n  @Input() infiniteScrollThrottle: number = 300;\n  @Input() infiniteScrollDisabled: boolean = false;\n  @Input() infiniteScrollContainer: any = null;\n  @Input() scrollWindow: boolean = true;\n  @Input() immediateCheck: boolean = false;\n  @Input() horizontal: boolean = false;\n  @Input() alwaysCallback: boolean = false;\n  @Input() fromRoot: boolean = false;\n\n  private disposeScroller: Subscription;\n\n  constructor(private element: ElementRef, private zone: NgZone) { }\n\n  ngAfterViewInit() {\n    if (!this.infiniteScrollDisabled) {\n      this.setup();\n    }\n  }\n\n  ngOnChanges({ infiniteScrollContainer, infiniteScrollDisabled, infiniteScrollDistance }: SimpleChanges) {\n    const containerChanged = inputPropChanged(infiniteScrollContainer);\n    const disabledChanged = inputPropChanged(infiniteScrollDisabled);\n    const distanceChanged = inputPropChanged(infiniteScrollDistance);\n    const shouldSetup = (!disabledChanged && !this.infiniteScrollDisabled) ||\n      (disabledChanged && !infiniteScrollDisabled.currentValue) || distanceChanged;\n\n    if (containerChanged || disabledChanged || distanceChanged) {\n      this.destroyScroller();\n      if (shouldSetup) {\n        this.setup();\n      }\n    }\n  }\n\n  setup() {\n    if (hasWindowDefined()) {\n      this.zone.runOutsideAngular(() => {\n        this.disposeScroller = createScroller({\n          fromRoot: this.fromRoot,\n          alwaysCallback: this.alwaysCallback,\n          disable: this.infiniteScrollDisabled,\n          downDistance: this.infiniteScrollDistance,\n          element: this.element,\n          horizontal: this.horizontal,\n          scrollContainer: this.infiniteScrollContainer,\n          scrollWindow: this.scrollWindow,\n          throttle: this.infiniteScrollThrottle,\n          upDistance: this.infiniteScrollUpDistance\n        }).subscribe((payload: any) => this.zone.run(() => this.handleOnScroll(payload)));\n      });\n    }\n  }\n\n  handleOnScroll({ type, payload }: IInfiniteScrollAction) {\n    switch (type) {\n      case InfiniteScrollActions.DOWN:\n        return this.scrolled.emit(payload);\n\n      case InfiniteScrollActions.UP:\n        return this.scrolledUp.emit(payload);\n\n      default:\n        return;\n    }\n  }\n\n  ngOnDestroy() {\n    this.destroyScroller();\n  }\n\n  destroyScroller() {\n    if (this.disposeScroller) {\n      this.disposeScroller.unsubscribe();\n    }\n  }\n}\n","import { NgModule } from '@angular/core';\n\nimport { InfiniteScrollDirective } from './infinite-scroll.directive';\n\n@NgModule({\n  declarations: [InfiniteScrollDirective],\n  exports: [InfiniteScrollDirective],\n  imports: [],\n  providers: []\n})\nexport class InfiniteScrollModule { }\n"],"names":["resolveContainerElement","selector","scrollWindow","defaultElement","fromRoot","hasWindow","window","document","documentElement","container","findElement","nativeElement","Error","customRoot","querySelector","inputPropChanged","prop","firstChange","hasWindowDefined","shouldTriggerEvents","alwaysCallback","shouldFireScrollEvent","isTriggeredCurrentTotal","createResolver","_a","windowElement","createResolverWithContainer","axis","isWindow","isElementWindow","resolver","Object","assign","some","obj","prototype","toString","call","includes","getDocumentElement","isContainerWindow","calculatePoints","element","height","extractHeightForElement","calculatePointsForWindow","calculatePointsForElement","extractHeightPropKeys","offsetHeightKey","clientHeightKey","scrolled","getElementPageYOffset","nativeElementHeight","getElementHeight","totalToScroll","getElementOffsetTop","scrollTopKey","scrollHeightKey","_b","elem","isNaN","topKey","getBoundingClientRect","pageYOffset","pageYOffsetKey","scrollTop","offsetTop","offsetTopKey","ownerDocument","defaultView","distance","scrollingDown","remaining","containerBreakpoint","scrolledUntilNow","down","up","isScrollingDownwards","lastScrollPosition","getScrollStats","scrollDown","fire","updateScrollPosition","position","scrollState","updateTotalToScroll","lastTotalToScroll","updateTriggeredFlag","scroll","triggered","isScrollingDown","isTriggeredScroll","updateScrollState","createScroller","config","scrollContainer","AxisResolver","horizontal","startWithTotal","options","throttle","upDistance","downDistance","attachScrollEvent","mergeMap","ev","of","map","positionStats","toInfiniteScrollParams","do","stats","ScrollResolver.updateScrollState","filter","ScrollResolver.isTriggeredScroll","ScrollResolver.updateTriggeredFlag","toInfiniteScrollAction","Observable","fromEvent","sampleTime","response","currentScrollPosition","type","InfiniteScrollActions","DOWN","UP","payload","vertical","this","InfiniteScrollDirective","zone","EventEmitter","scrolledUp","infiniteScrollDistance","infiniteScrollUpDistance","infiniteScrollThrottle","infiniteScrollDisabled","infiniteScrollContainer","immediateCheck","ngAfterViewInit","setup","ngOnChanges","containerChanged","disabledChanged","distanceChanged","shouldSetup","currentValue","destroyScroller","_this","runOutsideAngular","disposeScroller","disable","subscribe","run","handleOnScroll","emit","ngOnDestroy","unsubscribe","decorators","Directive","args","ctorParameters","ElementRef","NgZone","propDecorators","Output","Input","InfiniteScrollModule","NgModule","declarations","exports","imports","providers"],"mappings":"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"}